#!/usr/bin/perl
#
# $Id: note,v 1.7 2000/02/25 21:00:15 tom Exp tom $ $Author: tom $ $Revision: 1.7 $
#
# $Log: note,v $
# Revision 1.7  2000/02/25 21:00:15  tom
# corrected small timestamp problem in &edit and &new
#
# Revision 1.6  2000/02/25 13:23:25  tom
# fixed a small bug, that caused to use the last line for a note title instead the 2nd.
#
# Revision 1.5  2000/02/25 10:19:58  tom
# help modified about topic sep...
#
# Revision 1.4  2000/02/25 10:13:06  tom
# added $TopicSep
#
# Revision 1.3  2000/02/25 09:46:06  tom
# removed usage of gnu date, use localtime instead
#
# Revision 1.2  2000/02/25 09:24:27  tom
# changed to use strict, seems all still working ;-)
#
# Revision 1.1  2000/02/25 08:23:20  tom
# Initial revision
#
#
# this is the small console program "note" (BINARY version)
# It works similar to some well known GUI note programs,
# but instead of using X11 it uses the UN*X console.
# You can edit existing notes, delete them, create new
# ones and, of course display them.
# The notes will be stored in a binary data file (~/.notedb)
#
# If there exists a configfile called ~/.noterc then it will
# be processed. You can overwrite some default values of note.
#
# If you find it usefull or find a bug, please let me know:
# Thomas Linden <tom@daemon.de>

#use Data::Dumper;



sub usage;
sub find_editor;
sub output;
sub C;
sub uen;
sub ude;
sub num_bereich;
sub getdate;

sub new;
sub edit;
sub del;
sub display;
sub list;
sub help;
sub import;

use IO::Seekable;
use strict;


my (
	$maxlen, $timelen, $TOPIC, $TYPE, $mode, $NOTEDB,
	$version, $number, $CurTopic, $CurDepth, $PATH, $CONF,
	$sizeof, $MAX_TIME, $PreferredEditor, %TP, $TopicSep,
	$ListType, $searchstring, $dump_file, $ALWAYS_INT,
	$BORDERC, $BORDER_COLOR, $_BORDERC, $NOTEC, $NOTE_COLOR,
	$NUMC, $NUM_COLOR, $_NUMC, $_NOTEC, $TIMEC, $TIME_COLOR,
	$_TIMEC, $TOPICC, $TOPIC_COLOR, $_TOPICC, $SetTitle, $COLOR,
	$typedef, $MAX_NOTE, $MAX_TIME, @NumBlock, $ALWAYS_EDIT, $HOME
   );

#################################################
# define some default values.
# You can change them, but be carefull!
# Instead you can define each of them in a configfile
# called ~/.noterc.
$MAX_NOTE = 1024;
$MAX_TIME = 64;

$maxlen = 20;
$timelen = 22;
$HOME = `echo \$HOME`;
chomp $HOME;

$CONF = $HOME . "/.noterc";

$NOTEDB = $HOME . "/.notedb";

$COLOR = "NO";
# if $COLOR equals NO, then the following color-definitions
# will be replaced by "".
$BORDER_COLOR = "BLACK";
$NUM_COLOR    = "blue";
$NOTE_COLOR   = "magenta";
$TIME_COLOR   = "black";
$TOPIC_COLOR = "BLACK";

# Turns Topic Support on
$TOPIC = 1;

# Default topic separator: \
$TopicSep = '/';

$version = "0.6 (binary database)";

if($TOPIC)
{
    $CurDepth = 1; # the current depth inside the topic "directory" structure...
}
#################################################


# process command line args
if($ARGV[0] eq "")
{
        $mode = "new";
}
else
{
  while($ARGV[0] ne "" )
  {
        if($ARGV[0] =~ /^\d/)
        {
                # first arg is a digit!
                $number = $ARGV[0];
                if($mode eq "")
                {
                        # change mode only, if started with an option 
                        # ($mode will be already set)
                        $mode = "display";
                }
                $ARGV[0] = "";
        }
		elsif($ARGV[0] eq "-i" || $ARGV[0] eq "--interactive")
		{
				$mode = "interactive";
				$ARGV[0] = "";
		}
        elsif($ARGV[0] eq "-l" || $ARGV[0] eq "--list")
        {
                $mode = "list";
		my @ArgTopics = split /$TopicSep/,$ARGV[1];
		$CurDepth += $#ArgTopics + 1 if $ARGV[1];
		$CurTopic = $ArgTopics[$#ArgTopics]; # use the last element everytime...
                $ARGV[0] = "";
        }
	elsif($ARGV[0] eq "-L" || $ARGV[0] eq "--longlist")
	{
		$mode = "list";
		$ListType = "LONG";
		$CurTopic = $ARGV[1];
               	$ARGV[0] = "";
	}
        elsif($ARGV[0] eq "-s" || $ARGV[0] eq "--search")
        {
                # searching
                $mode = "search";
                $searchstring = $ARGV[1];
                $ARGV[0] = "";
        }
        elsif($ARGV[0] eq "-e" || $ARGV[0] eq "--edit")
        {
                if($mode eq "edit")
                {
                        # note -e -e !
                        &usage;
                        exit(1);
                }
                else
                {
                        $mode = "edit";
                        shift;
                }
        }
        elsif($ARGV[0] eq "-d" || $ARGV[0] eq "--delete")
        {
                if($mode eq "delete")
                {
                        &usage;
                        exit(1);
                }
                else
                {
                        $mode = "delete";
                        shift;
                }
        }
	elsif($ARGV[0] eq "-D" || $ARGV[0] eq "--Dump" || $ARGV[0] eq "--dump")
	{
			$mode = "dump";
			$dump_file = $ARGV[1];
			$ARGV[0] = "";
			if($dump_file eq "")
                        {
                               $dump_file = "note.dump.$$";
                               print "not dumpfile specified, using $dump_file.\n";
                        }
	}
	elsif($ARGV[0] eq "-I" || $ARGV[0] eq "--Import" || $ARGV[0] eq "--import")
	{
		$mode = "import";
		$dump_file = $ARGV[1];
                $ARGV[0] = "";
                if($dump_file eq "")
                {
                        print "No dumpfile specified.\n";
			exit(1);
                }
	}
        elsif($ARGV[0] eq "-v" || $ARGV[0] eq "--version")
        {
                print "This is note $version by Thomas Linden <tom\@daemon.de>.\n";
                exit(0);
        }
        elsif($ARGV[0] eq "-h" || $ARGV[0] eq "--help")
        {
                &usage;
                exit(0);
        }
        else
        {
                &usage;
        		exit(0);
        }
  }
}

###################### CONFIG ~/.noterc exists? #########################
# If not, use the predefined Values!
if(-e $CONF)
{
        eval `cat $CONF`;
}

# Always interactive?
if($ALWAYS_INT eq "YES" && $mode ne "dump" && $mode ne "import")
{
	$mode = "interactive";
}


###################### db exists? #######################################
# if not, create it!
if(! -e $NOTEDB)
{
	open(TT,">$NOTEDB") or die "Could not create $NOTEDB: $!\n";
	close (TT);
}
elsif(! -w $NOTEDB)
{
	print "$NOTEDB is not writable!\n";
	exit(1);
}


# calculate some constants...
$BORDERC  = "<$BORDER_COLOR>";
$_BORDERC = "</$BORDER_COLOR>";
$NUMC     = "<$NUM_COLOR>";
$_NUMC    = "</$NUM_COLOR>";
$NOTEC    = "<$NOTE_COLOR>";
$_NOTEC   = "</$NOTE_COLOR>";
$TIMEC    = "<$TIME_COLOR>";
$_TIMEC   = "</$TIME_COLOR>";
$TOPICC	  = "<$TOPIC_COLOR>";
$_TOPICC  = "</$TOPIC_COLOR>";


$typedef = "i a$MAX_NOTE a$MAX_TIME";
$sizeof  = length pack($typedef, () );


if($ListType ne "LONG" && $mode ne "interactive")
{
     $maxlen += $timelen; # no time will be displayed!
}


# main loop: ###############
if($mode eq "display")
{
	&display;
}
elsif($mode eq "search")
{
	&search;
}
elsif($mode eq "list")
{
	&list;
}
elsif($mode eq "new")
{
	&new;
}
elsif($mode eq "delete")
{
	del;
}
elsif($mode eq "edit")
{
	&edit;
}
elsif($mode eq "dump")
{
	&dump;
}
elsif($mode eq "import")
{
	&import;
}
elsif($mode eq "interactive")
{
	&interactive;
}
else
{
        #undefined :-(
}


exit(0);
################## EOP ################



############################### DISPLAY ##################################
sub display
{
        my($N,$address,$buffer,$n,$t,$match,$note,$time,$num);
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
	&num_bereich; # get @NumBlock from $numer
	foreach $N (@NumBlock)
	{
		$address = ($N -1 ) * $sizeof;
		seek(NOTE, $address, SEEK_SET);
		read(NOTE, $buffer, $sizeof);
		($num, $note, $time) = unpack($typedef, $buffer);
		$n = ude($note);
		$t = ude($time);	
		if($num)
		{
			output($num, $n, $t, "SINGLE");
			print "\n";
			$match = 1;
		}
	}
	close(NOTE);
	if(!$match)
	{
		print "no note with that number found!\n";
	}
}


############################### SEARCH ##################################
sub search
{
        my($n,$t,$match,$note,$time,$num,$buffer);
	$maxlen += $timelen;
	if($searchstring eq "")
        {
                &usage;
                exit(1);
        }
	print "searching the database $NOTEDB for \"$searchstring\"...\n";
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
        seek(NOTE, 0, 0); # START FROM BEGINNING
        while(read(NOTE, $buffer, $sizeof))
        {
                ($num, $note, $time) = unpack($typedef, $buffer);
                $n = ude($note);
                $t = ude($time);
		if($n =~ /$searchstring/i)
                {
			output($num, $n, $t);
			$match = 1;
		}
        }
	if(!$match)
	{
		print "no matching note found!\n";
	}
        close(NOTE);
        print "\n";
}


############################### LIST ##################################
sub list
{
	#system("clear") or print "\n\n\n\n";
	my(@topic,@RealTopic, $i,$buffer,$t,$n,$num,$note,$time,@CurItem,$top,$in);
	if($mode ne "interactive")
	{
		print "List of all existing notes:\n\n";
	}
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
        seek(NOTE, 0, 0); # START FROM BEGINNING
	if($TOPIC)
        {
                undef %TP; # the beginning!
	}
	$i = 0;
        while(read(NOTE, $buffer, $sizeof))
        {
                ($num, $note, $time) = unpack($typedef, $buffer);
                $t = ude($time);
		$n = ude($note);
		if($TOPIC)
		{
			# this allows us to have multiple topics (subtopics!)
			my ($firstline,$dummy) = split /\n/, $n, 2;
			if($firstline =~ /^($TopicSep)/)
			{
				@topic = split(/$TopicSep/,$firstline); 
			}
			else
			{
			        @topic = ();
			}
			# looks like: "\topic\"
		        # collect a list of topics under the current topic
			if($topic[$CurDepth-1] eq $CurTopic && $topic[$CurDepth] ne "")
			{
                		if(exists $TP{$topic[$CurDepth]})
                		{
                		        $TP{$topic[$CurDepth]}++;
                		}
                		else
                		{
				    	# only if the next item *is* a topic!
                		        $TP{$topic[$CurDepth]} = 1 if(($CurDepth) <= $#topic);
                		}
			}
			elsif($topic[$CurDepth-1] eq $CurTopic || ($topic[$CurDepth] eq "" && $CurDepth ==1))
			{
				# cut the topic off the note-text
                                if($n =~ /^($TopicSep)/)
                                {
                                        $CurItem[$i]->{'note'} = $dummy;
                                }
                                else
                                {
                                        $CurItem[$i]->{'note'} = $n;
                                }

				# save for later output() call
				$CurItem[$i]->{'num'}  = $num;
				$CurItem[$i]->{'time'} = $t;
				$i++;
				# use this note for building the $PATH!
				if($RealTopic[0] eq "")
				{
				    @RealTopic = @topic;
				}
			}
		}
		else
		{
			output($num, $n, $t);
        	}
	}
	if($TOPIC)
	{
	        if($CurTopic ne "")
		{
		    undef $PATH;
		    foreach (@RealTopic)
		    {
			$PATH .= $_ . $TopicSep;
			last if($_ eq $CurTopic);
		    }
		}
		else
		{
		    $PATH = $TopicSep;
		}
		
		# we are at top level, print a list of topics...
		foreach $top (sort(keys %TP))
		{
			output("-", " => ". $top . "$TopicSep ($TP{$top} notes)",
			 	" Sub Topic         ");
		}
		for($in=0;$in<$i;$in++)
		{
		        output( $CurItem[$in]->{'num'},
				$CurItem[$in]->{'note'},
				$CurItem[$in]->{'time'} ); 
		}
	}
        close(NOTE);
	print "\n";
}


############################### NEW ##################################
sub new
{
    my($time, $TEMP,$editor, $note, $WARN, $c, $line, $num, $te, $me, $buff,$buffer, @topic,$n,$t);
	$time = &getdate;
	if($ALWAYS_EDIT eq "YES")
	{
		$TEMP = "/tmp/note.$$";
		# let the user edit it...
	    	$editor = &find_editor;
        	if($editor)
        	{
        	        system $editor, $TEMP;
        	}
        	else
        	{
        	        print "Could not find an editor to use!\n";
        	        exit(0);
        	}
    		# read it in ($note)
    		$note = "";
    		#open E, "<$TEMP" or die "Could not open $TEMP\n";
    		open E, "<$TEMP" or $WARN = 1; 
		if($WARN)
		{
			print "...edit process interupted! No note has been saved.\n"; 
			undef $WARN;
			return;
		}
		$c = 0;
    		while(<E>)
    		{
    		    $note = $note . $_;
    		}
    		chomp $note;
    		close E;
   		# privacy!
   	 	system "/bin/rm -f $TEMP";
	}
	else
	{
		$note = "";
		$line = "";
		#local $num = 0;
		# create a new note
    		print "enter the text of the note, end with .\n";
		do
    		{
    		      $line = <STDIN>;
    		      $note = $note . $line;
    		} until $line eq ".\n";
		# remove the . !
    		chop $note;
    		chop $note;
	}
	open (N, "<$NOTEDB") or die "could not open .notedb\n";
	# since we have not number, look for the next available:
	seek(N, 0, 0); # START FROM BEGINNING	
	while(read(N, $buff, $sizeof))
        {
                ($num, $te, $me) = unpack($typedef, $buff);
        }
	seek(N, 0, 0);
	close (N);
	$num++; # use the highest plus 1

	if($TOPIC && $CurTopic ne "")
	{
		@topic = split(/$TopicSep/,$note);
		if($topic[1] eq "")
		{
			#$note = "\\$CurTopic\\\n$note";
			$note = $PATH . "\n$note";
		}
	}
	
	
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
	seek(NOTE, 0, SEEK_END); # APPEND
	$n = uen($note);
	$t = uen($time);
	$buffer = pack($typedef, $num, $n, $t);

	print NOTE $buffer;
	close(NOTE);
	print "note stored. it has been assigned the number $num.\n\n";
}


############################### DELETE ##################################
sub del
{
    my($TEMP,$count, $buff, %Merk, $num, $note, $time, $droped, $buffer);
	&num_bereich; # get @NumBlock from $number
	$TEMP = "/tmp/note.$$"; # save temporarily in $TEMP
	system("/bin/touch", $TEMP);
	open TEMP, "+<$TEMP" or die "Could not open $TEMP($!)\n";
	open (NOTE, "<$NOTEDB") or die "could not open .notedb\n";

	seek(TEMP, 0, SEEK_END); # APPEND

	$count = 1;

	# read from notedb and write to temp (without number to
	# be deleted, and with recounted numbers)

	foreach (@NumBlock)
	{
		# define $Merk's for the exists() test later on...
		$Merk{$_} = "got";
	}

	while(read(NOTE, $buff, $sizeof))
	{
		($num, $note, $time) = unpack($typedef, $buff);
		if(exists $Merk{$num})
		{
                # drop it, just ignore the contents.
                $droped = 1;
                print "note number $num has been deleted.\n";
        }
		else
		{   
                # no keep it
                $buffer = pack($typedef, $count, $note, $time);
                seek(TEMP, 0, SEEK_END); # APPEND
                print TEMP $buffer;
                $count++;    
        }
	}




	close(TEMP);
	close(NOTE);
	
	# done, inform the user
	if($droped eq 1)
	{
		# copy the new one over the old one
		system("/bin/cp",$TEMP, $NOTEDB);
	}
	else
	{
		print "no note with that number found!\n";
	}
	system "/bin/rm -f $TEMP";
}


############################### EDIT ##################################
sub edit
{
    my($time,$editor, $TEMP, $address, $n, $buff, $c, $note, $t, $buffer, $num);
	$time = &getdate;
	$address = ($number -1 ) * $sizeof;
    	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
    	seek(NOTE, $address, SEEK_SET);
	read(NOTE, $buff, $sizeof) or die "no note with that number found!\n";
	($num, $note, $t) = unpack($typedef, $buff);
        $n = ude($note);
	# got current enties...
	
	# now edit them
	$TEMP = "/tmp/note.$$";
	open N, ">$TEMP" or die "Could not open $TEMP\n";
	select N;
	print $n; # save decoded to $TEMP
	close N;
	select STDOUT;

	# let the user edit it...
	$editor = &find_editor;
        if($editor)
        {
                system $editor, $TEMP;
        }
        else
        {
                print "Could not find an editor to use!\n";
                exit(0);
        }

	# read it in ($note)
	$note = "";
	open N, "<$TEMP" or die "Could not open $TEMP\n";
	$c = 0;
	while(<N>)
	{
		$note = $note . $_;
	}
	chomp $note;
	close N;

	# privacy!
	system "/bin/rm -f $TEMP";

	# we got it, now save to db
	seek(NOTE, $address, SEEK_SET);
	$n = "";
	$n = uen($note);
	$t = uen($time);
	$buffer = pack($typedef, $number, $n, $t);
        print NOTE $buffer;
	close(NOTE);
	print "note number $number has been changed.\n";
}


sub dump
{
    my($buffer,$num, $note, $time,$n, $t);
	# $dump_file
	open (DUMP, ">$dump_file") or die "could not open $dump_file\n";
	select DUMP;
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
        seek(NOTE, 0, 0); # START FROM BEGINNING
        while(read(NOTE, $buffer, $sizeof))
        {
                ($num, $note, $time) = unpack($typedef, $buffer);
                $n = ude($note);
                $t = ude($time);
		print STDOUT "dumping note number $num to $dump_file\n";
                print "Number: $num\nTimestamp: $t\n$n\n";
        }
        close(NOTE);
        print "\n";
	close(DUMP);
	select STDOUT;
}

sub import
{
    my($buff, $num,$te, $me, $start, $complete, $dummi, $n, $t, $buffer, $note, $time, $date);
	open (N, "<$NOTEDB") or die "could not open .notedb\n";
        # since we have not number, look for the next available:
        seek(N, 0, 0); # START FROM BEGINNING   
        while(read(N, $buff, $sizeof))
        {
                ($num, $te, $me) = unpack($typedef, $buff);
        }
        seek(N, 0, 0);
        close (N);
        $num++; # use the highest plus 1

        # open $dump_file and import it into the notedb
        open (DUMP, "<$dump_file") or die "could not open $dump_file\n";
        $complete=0;
        $start = 0;
	open (NOTE, "+<$NOTEDB") or die "could not open .notedb\n";
        while(<DUMP>)
        {
                chomp $_;
                if($_ =~ /^Number:\s\d+/)
                {
                        if($start == 0)
                        {
                                # we have no previous record
                                ($dummi,$number) = split(/\s/,$_);
                                $start = 1;
                        }
                        else
                        {
                                # we got a complete record, save it!

				seek(NOTE, 0, SEEK_END); # APPEND
				$n = uen($note);
				$t = uen($date);
				$buffer = pack($typedef, $num, $n, $t);
				print NOTE $buffer;
				$num++;

                                print "note number $number from $dump_file inserted into notedb.\n";
                                $complete = 0; # restet $complete 
                                $note = "";    # reset $note
                                $date = "";    # reset $date
                                ($dummi,$number) = split(/\s/,$_);
                        }       
                }
                elsif($_ =~ /^Timestamp:\s\d+/ && $complete == 0)
                {
                        ($dummi,$date,$time) = split(/\s/,$_);
                        $date = "$date $time";
                        $complete = 1;
                }
                else
                {
                        $note .= $_ . "\n";
                }
        }
        if($note ne "" && $date ne "")
        {
                # the last record, if existent
		seek(NOTE, 0, SEEK_END); # APPEND
		$n = uen($note);
		$t = uen($date);
		$buffer = pack($typedef, $num, $n, $t);
		print NOTE $buffer;
                print "note number $number from $dump_file inserted into notedb.\n";
        	close(NOTE);
	}
}






sub interactive
{
    my($maxlen_save, $B, $BB, $menu, $time, $char, @LastTopic); 
	$maxlen_save = $maxlen;
	# create menu:
	$B = "<blackI>";
	$BB = "</blackI>";
	$menu =     "[" .  $B . "L" . $BB . " List "
			. $B . "N" . $BB . " New "
			. $B . "D" . $BB . " Delete "
			. $B . "S" . $BB . " Search "
			. $B . "E" . $BB . " Edit "
			. $B . "?" . $BB . " Help "
			. $B . "Q" . $BB . " Quit] "; # $CurTopic will be empty if $TOPIC is off!
	# Initially do a list command!
	$maxlen += $timelen;
	print "\n";
	&list;
	undef $SetTitle;
	# per default let's list all the stuff:
	for(;;)
	{
		# reset time
		$ListType = "";
		$maxlen = $maxlen_save;
		if($CurDepth > 2)
		{
		    print C $menu . $TOPICC . "../" . $CurTopic . $_TOPICC . ">";
		}
		else
		{
		    print C $menu . $TOPICC . $CurTopic . $_TOPICC . ">";
		}
		# endless until user press "Q" or "q"!
		$char = <STDIN>;
		chomp $char;
		if($char =~ /^\d+/)
		{
			# display notes
			$maxlen += $timelen;
			$number = $char;
			&display;
			undef $SetTitle;
		}
		elsif($char =~ /^n$/i)
		{
			# create a new one
			&new;
		}
		elsif($char =~ /^l$/ || $char =~ /^$/)
		{
			# list
			print "\n";
			$ListType = "";
			$maxlen += $timelen;
			&list;
			undef $SetTitle;
		}
		elsif($char =~ /^L$/)
		{
			$ListType = "LONG";
			print "\n";
			&list;
			undef $SetTitle;
		}
		elsif($char =~ /^h$/i || $char =~ /^\?/)
		{
			# zu dumm der Mensch ;-)
			&help;
		}
		elsif($char =~ /^d\s+(\d+\-*\,*\d*)/i)
		{
			# delete one!
			$number = $1;
			&del;
		}
		elsif($char =~ /^d$/i)
		{
			# we have to ask her:
			print "enter number(s) of note(s) you want to delete: ";
			$char = <STDIN>;
			chomp $char;
			$number = $char;
			&del;
		}
		elsif($char =~ /^e\s+(\d+\-*\,*\d*)/i)
		{
			# edit one!
			$number = $1;
			&edit;
		}
		elsif($char =~ /^e$/i)
		{
			# we have to ask her:
			#$maxlen += $timelen;
			print "enter number of the note you want to edit: ";
			$char = <STDIN>;
			chomp $char;
			$number = $char;
			&edit;
		}
		elsif($char =~ /^s\s+/i)
		{
			# she want's to search
			$searchstring = $';
			chomp $searchstring;
			&search;
		}
		elsif($char =~ /^s$/i)
		{
			# we have to ask her:
			print "enter the string you want to search for: ";
			$char = <STDIN>;
			chomp $char;
			$char =~ s/^\n//;
			$searchstring = $char;
			&search;
		}
		elsif($char =~ /^q$/i)
		{
			# schade!!!
			print "\n\ngood bye\n";
			exit(0);
		}
		elsif($char =~ /^\.\.$/)
		{
		    	$CurDepth-- if ($CurDepth > 1);
			$CurTopic = $LastTopic[$CurDepth];
			$maxlen += $timelen;
			print "\n";
			&list;
			undef $SetTitle;
		}
		else
		{
			# unknown
			if(exists $TP{$char})
			{
			    	$LastTopic[$CurDepth] = $CurTopic;
				$CurTopic = $char;
				$maxlen += $timelen;
				$CurDepth++;
				print "\n";
        			&list;
				undef $SetTitle;
			}
			else
			{
				print "\nunknown command!\n";
			}
		}
	}
}



sub usage
{
print qq~This is the program note $version by Thomas Linden (c) 1999-2000.
It comes with absolutely NO WARRANTY. It is distributed under the
terms of the GNU General Public License. Use it at your own risk :-)
Usage: 		note [-i | --interactive] | [ options ] [ number [,number...]]
Options:
	-h	--help			displays this help screen
	-v	--version		displays the version number
	-l	--list [<topic>]	lists all existing notes. If no topic were specified,
					it will display a list of all existing topics.
	-L	--longlist [<topic>]	the same as -l but prints also the timestamp
	-s	--search <string>	searches for <string> trough the notes database
	-e	--edit <number>		edit note with <number>
	-d	--delete <number>	delete note with <number>
	-D	--Dump [<file>]		dumps the notes to the textfile <file>
	-I	--Import <file>		imports a previously dumped textfile into the
					note-database. Dumps from the mysql and the binary
					version are in the same format.
	-i	--interactive		interactive mode

 o if you specify only a number (i.e. "note 4"), then the note with that
   number will be displayed.
 o you can specify more then one number for delete and display, for example:
   "note -d 3,4" deletes #3 and #4. "note 5-7" displays #5, #6 and #7.
 o if you run note without any parameter and if \$ALWAYS_INT in the config is
   not set, then note will create a new note and prompt you for new text.
 o If it finds \~/.noterc, it will process it. Refer to the manpage for more
   informations about the configuration.
 o In interactive mode you can get help at any time by typing "?" or "h" at
   the prompt.
~;
  exit 1;
}
sub find_editor {
   return $PreferredEditor || $ENV{"VISUAL"} || $ENV{"EDITOR"} || "vim" || "vi" || "pico";
}

#/

sub output
{
    my($SSS, $LINE, $num, $note, $time, $TYPE, $L, $LONGSPC, $R, $PathLen, $SP, $title, $CUTSPACE,
       $len, $diff, $Space);
	# 0 = Num, 1 = Note, 2 = Time
	if($ListType ne "LONG")
	{
		$SSS = "-" x ($maxlen + 31 - $timelen);
	}
	else
	{
		$SSS = "-" x ($maxlen + 31);
	}
	$LINE = "$BORDERC $SSS $_BORDERC\n";
	$num   = $_[0];
	$note  = $_[1];
	$time  = $_[2];
	$TYPE  = $_[3];
	$L = $BORDERC . "[" . $_BORDERC;
	$LONGSPC = " " x (22 + 3);
        $R = $BORDERC . "]" . $_BORDERC;
	$PathLen = length($PATH); # will be ZERO, if not in TOPIC mode!
	if($TYPE ne "SINGLE")
	{
		if(!$SetTitle) 
		{
			$SP = "";
			# print only if it is the first line!
			if($ListType ne "LONG")
			{
				$SP = " " x ($maxlen-2 - $timelen - $PathLen);
                	}
			else
			{
				$SP = " " x ($maxlen-2 - $PathLen);
			}
			print C $LINE;
		
			print C "$L $NUMC#$_NUMC  ";
			if($ListType eq "LONG")
			{
				print C " $TIMEC" . "creation date$_TIMEC           ";
			}
			else
			{
				print $LONGSPC;
			}
			if($TOPIC)
			{
			    print C $TOPICC . "$PATH    $_TOPICC$SP$R\n";
			}
			else
			{
			    print C $NOTEC . "note$_NOTEC$SP$R\n";
			}

                	print C $LINE;
			$SetTitle = 1;
		}
		$title = "";
		$CUTSPACE = " " x $maxlen;
		$note =~ s/\n/$CUTSPACE/g;
        	$len = length($note);
        	if($len < $maxlen-3)
        	{
        	    $diff = $maxlen - $len;
		    $Space = " " x $diff;	
		    if($num eq "-")
		    {
			$title = $BORDERC . $TOPICC . "\"" . $note . "\"" . $_TOPICC . $Space . "$_BORDERC";
		    }
		    else
		    {
        	        $title = $BORDERC . $NOTEC . "\"" . $note . "\"" . $_NOTEC . $Space . "$_BORDERC";
        	    }
		}
		else
        	{
        	        $title = substr($note,0,$maxlen - 3);
			if($num eq "-")
			{
			    $title = $BORDERC . $TOPICC . "\"" . $title . "...\"$_TOPICC$_BORDERC";
			}
			else
			{
        	            $title = $BORDERC . $NOTEC . "\"" . $title . "...\"$_NOTEC$_BORDERC";
			}
        	}
		# $title should now look as: "A sample note                       "
       		print C "$L $NUMC$num$_NUMC $R";
		if($ListType eq "LONG")
		{
			print C "$L$TIMEC" . $time . " $_TIMEC$R"; 
		}
		print C "$L $NOTEC" . $title . "$_NOTEC $R\n";


		print C $LINE;
	}
	else
	{
		chomp $note;
		$Space = " " x ($maxlen - 16);
		$SP = " " x ($maxlen + 13);
		#print C $LINE;
		#print C "$L $NUMC#$_NUMC   " . $TIMEC . "creation date$_TIMEC$SP$R\n";
		print C $LINE;
		print C "$L $NUMC$num$_NUMC $R$L$TIMEC$time$_TIMEC $Space$R\n";
		print C $LINE;
		print C $NOTEC . $note . $_NOTEC . "\n";
		print C $LINE;
	}
	
}



sub C
{
    my(%Color, $default, $S, $Col, $NC, $T);
        # \033[1m%30s\033[0m    
        %Color    = (        'black'         => '0;30',
                                'red'           => '0;31',
                                'green'         => '0;32',
                                'yellow'        => '0;33',
                                'blue'          => '0;34',
                                'magenta'       => '0;35',
                                'cyan'          => '0;36',
                                'white'         => '0;37',
				'B'		=> '1;30',
                                'BLACK'         => '1;30',
                                'RED'           => '1;31',
                                'GREEN'         => '1;32',
                                'YELLOW'        => '1;33',
                                'BLUE'          => '1;34',
                                'MAGENTA'       => '1;35',
                                'CYAN'          => '1;36',
                                'WHITE'         => '1;37',
                                'black_'        => '4;30',
                                'red_'          => '4;31',
                                'green_'        => '4;32',
                                'yellow_'       => '4;33',
                                'blue_'         => '4;34',
                                'magenta_'      => '4;35',
                                'cyan_'         => '4;36',
                                'white_'        => '4;37',
                                'blackI'        => '7;30',
                                'redI'          => '7;31',
                                'greenI'        => '7;32',
                                'yellowI'       => '7;33',
                                'blueI'         => '7;34',
                                'magentaI'      => '7;35',
                                'cyanI'         => '7;36',
                                'whiteI'        => '7;37'
                        ); 
        $default = "\033[0m";
        $S = $_[0];
        foreach $Col (%Color)
        {
                if ($S =~ /<$Col>/g)
                {
			if($COLOR ne "NO")
			{
                        	$NC = "\033[" . $Color{$Col} . "m";     
                        	$S =~ s/<$Col>/$NC/g;
                        	$S =~ s/<\/$Col>/$default/g;
                	}
			else
			{
				$S =~ s/<$Col>//g;
                                $S =~ s/<\/$Col>//g;
			}
		}
        }
        return $S;
}


sub uen
{
    my($T);
	$T = pack("u", $_[0]);
	chomp $T;
	return $T;
}

sub ude
{
    my($T);
        $T = unpack("u", $_[0]);
        return $T;
}

sub num_bereich
{
    # $number is the one we want to delete!
    # But does it contain kommas?
    my($m,@LR,@Sorted_LR,$i);
    if($number =~ /\,/)
    {
        # accept -d 3,4,7
        @NumBlock = split(/\,/,$number);
    }
    elsif($number =~ /^\d+\-\d+$/)
    {
        # accept -d 3-9
        @LR = split(/\-/,$number);
        @Sorted_LR = ();

        if($LR[0] > $LR[1])
        {
                @Sorted_LR = ($LR[1], $LR[0]);
        }
        elsif($LR[0] == $LR[1])
        {
                # 0 and 1 are the same
                @Sorted_LR = ($LR[0], $LR[1]);
        }
        else
        {
                @Sorted_LR = ($LR[0], $LR[1]);
        }

        for($i=$Sorted_LR[0]; $i<=$Sorted_LR[1]; $i++)
        {
            # from 3-6 create @NumBlock (3,4,5,6)
            $NumBlock[$m] = $i;
            $m++;
        }
    }
    else
    {
        @NumBlock = ($number);
    }

}


sub getdate
{
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $year += 1900;
    $mon += 1;
    $mon =~ s/^(\d)$/0$1/;
    $hour =~ s/^(\d)$/0$1/;
    $min =~ s/^(\d)$/0$1/;
    $sec =~ s/^(\d)$/0$1/;
    $mday =~ s/^(\d)$/0$1/;
    return "$mday.$mon.$year $hour:$min:$sec";
}

sub help
{
print qq~
--------------------------------------------------------------
HELP for interactive note       $version

The following commands are available:
L/l	List notes. L=long, with timestamp and l=short without timestamp.
	You can also just hit <enter> for short list.~;
if($TOPIC)
{
print qq~
        If a "note" starts with a - instead of a number, then it is a
	topic. In the brackets you will se, how many notes exists under
	that specific topic. Just type the name of the topic to change
	to that, it works, just like using cd on a filesystem (without the 
	cd command). If you type just "..", you will go to the last topic,
	you were before (works like "cd ..").
	You can create a new topic by creating a new note, the first line
	must be the topic borderd by "$TopicSep", i.e.: "/newtopic/". The default
	topic separator is "/".
	You can have as many subtopics, as you like, i.e.: "/pc/games/x11/".
	If you create a new note without a topic-specification, then it 
	will be put into the current subtopic.~;
}
print qq~
N	Create a new note.
D	Delete a note. You can either hit "d 1" or "d 1-4" or just hit "d".
	If you don't specify a number, you will be asked for.
S	Search trough the notes database. Usage is similar to Delete, use
	a string instead of a number to search for.
E	Edit a note. Usage is similar to Delete but you can only edit note
	a time.
?/H	This help screen.
Q	Exit the program.

All commands except the List command are case insensitive.
---------------------------------------------------------------
~;
}
